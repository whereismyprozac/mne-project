import mne
import numpy as np
from scipy.fft import fft, fftfreq
import matplotlib.pyplot as plt
import pandas as pd
import mne.viz as viz
from mne.io import concatenate_raws, read_raw_edf
from mne.datasets import eegbci

# raw_fnames = eegbci.load_data(subject, runs)
# raws = [read_raw_edf(f, preload=True) for f in raw_fnames]
# raw = concatenate_raws(raws)
# from sklearn.linear_model import LogisticRegression


def read_csv_with_different_encodings(file_path, encodings):
    for encoding in encodings:
        try:
            return pd.read_csv(file_path, encoding=encoding)  # Adjust the range as per the number of header rows
        except UnicodeDecodeError:
            continue
    raise ValueError(f'Could not read the file with any of the provided encodings: {encodings}')

file_path = r'C:\Users\hallo\OneDrive\Documents\mindMonitor_2023-10-31-updated.csv'
encodings = ['utf-8']
# Use the function to read the CSV
df = read_csv_with_different_encodings(file_path, encodings)

columns_to_check = ['Delta_TP9', 'Delta_AF7', 'Delta_AF8', 'Delta_TP10','Theta_TP9', 'Theta_AF7', 'Theta_AF8', 'Theta_TP10',
            'Alpha_TP9', 'Alpha_AF7', 'Alpha_AF8', 'Alpha_TP10',
            'Beta_TP9', 'Beta_AF7', 'Beta_AF8', 'Beta_TP10',
            'Gamma_TP9', 'Gamma_AF7', 'Gamma_AF8', 'Gamma_TP10',
            'RAW_TP9', 'RAW_AF7', 'RAW_AF8', 'RAW_TP10', 'AUX_RIGHT',
            'Accelerometer_X', 'Accelerometer_Y', 'Accelerometer_Z',
            'Gyro_X', 'Gyro_Y', 'Gyro_Z', 'HeadBandOn', 'HSI_TP9',
            'HSI_AF7', 'HSI_AF8', 'HSI_TP10', 'Battery']  # Add all other EEG columns here
for column in columns_to_check:
    df = df[pd.to_numeric(df[column], errors='coerce').notna()]
    
if 'Accelerometer_X' in df.columns:
    df = df.drop(columns=['Accelerometer_X'])  # Drop the Accelerometer_X column, it's not needed
if 'Accelerometer_Y' in df.columns:
    df = df.drop(columns=['Accelerometer_Y'])  # Drop the Accelerometer_Y column, it's not needed
if 'Accelerometer_Z' in df.columns:
    df = df.drop(columns=['Accelerometer_Z'])  # Drop the Accelerometer_Z column, it's not needed
    
if 'Gyro_X' in df.columns:
     df = df.drop(columns=['Gyro_X'])  # Drop the Gyro_X column, it's not needed
if 'Gyro_Y' in df.columns:
     df = df.drop(columns=['Gyro_Y'])  # Drop the Gyro_Y column, it's not needed
if 'Gyro_Z' in df.columns:
     df = df.drop(columns=['Gyro_Z'])  # Drop the Gyro_Z column, it's not needed

if 'Elements' in df.columns:
     df = df.drop(columns=['Elements'])  # Drop the Elements column, it's not needed

# # Extract timestamps, assuming it's the first column in the DataFrame
print(df.head())
TimeStamp = df.pop('TimeStamp').values


# print(df['TimeStamp'].head())


# Other columns are used as data
data = df.values.T  # Transpose data to fit MNE's expected data shape (channels x times)

# Define channel names and types
ch_names = ["Delta_TP9", "Delta_AF7", "Delta_AF8", "Delta_TP10", 
            "Theta_TP9", "Theta_AF7", "Theta_AF8", "Theta_TP10",
            "Alpha_TP9", "Alpha_AF7", "Alpha_AF8", "Alpha_TP10",
            "Beta_TP9", "Beta_AF7", "Beta_AF8", "Beta_TP10",
            "Gamma_TP9", "Gamma_AF7", "Gamma_AF8", "Gamma_TP10",
            "RAW_TP9", "RAW_AF7", "RAW_AF8", "RAW_TP10", "AUX_RIGHT",
            "HeadBandOn", "HSI_TP9", "HSI_AF7", "HSI_AF8", "HSI_TP10", "Battery"]  # add other channels as per your CSV file
ch_types = ["eeg"] * (len(ch_names)) #+ ["misc"] * (len(ch_names) - 24) # adjust types according to your channels: eeg, stim, eog, misc, etc.
# "Accelerometer_X", "Accelerometer_Y", "Accelerometer_Z",
# #             "Gyro_X", "Gyro_Y", "Gyro_Z",


sfreq = 500  # Sample frequency, adjust as necessary

# Create MNE info structure
info = mne.create_info(ch_names=ch_names, sfreq=sfreq, ch_types=ch_types)

raw = mne.io.RawArray(data, info)
# raw save to fif
raw.save(r'C:\Users\hallo\OneDrive\Documents\mindMonitor_2023-10-31-updated._eeg.fif', overwrite=True)
# raw load to fif
raw_from_fif = mne.io.read_raw_fif(r'C:\Users\hallo\OneDrive\Documents\mindMonitor_2023-10-31-updated._eeg.fif', preload=True)


raw = mne.io.read_raw_fif(r'C:\Users\hallo\OneDrive\Documents\mindMonitor_2023-10-31-updated._eeg.fif', preload=True)
print(raw.info)
print(raw)

#bandpass filter    
raw.filter(4, 60, fir_design='firwin', filter_length='auto')

# #refer to average
raw.set_eeg_reference('average', projection=True)
# #downsample
raw.resample(sfreq=128) #sfrq is the new sampling frequency
raw.apply_proj()

#note to Paul S. - please ignore lines 106 to 112
# channels_to_plot = ['RAW_TP9', 'RAW_AF7', 'RAW_AF8', 'RAW_TP10']

# # Selecting only the specified channels
# raw_selected = raw.pick_channels(channels_to_plot)

# # Plotting the selected channels
# raw_selected.plot(scalings='auto', title='Selected EEG Channels: RAW_TP9, RAW_AF7, RAW_AF8, RAW_TP10', show=True, block=True)


EPOCHING

raw_data = raw.get_data(picks=['RAW_TP9','RAW_AF7', 'RAW_AF8', 'RAW_TP10'])  
# if np.isnan(raw_data).any():
#     print("NaNs found in the data")
#     raw.interpolate_bads(reset_bads=True)

#  Define the shortest event possible in seconds 
try:
    shortest_event_sec =  1 / raw.info['sfreq']
    min_duration = 5 / raw.info['sfreq']

    shortest_event_samples = int(shortest_event_sec * raw.info['sfreq'])
        
    events = mne.find_events(raw, stim_channel=['RAW_TP9','RAW_AF7', 'RAW_AF8', 'RAW_TP10'])
except Exception as e:
    print(e)
    print("No events found in the data")
    events = np.array([[0, 0, 0]])
# # , uint_cast=True, initial_event=True
# # 


event_id = {'Left': 1, 'Right': 2}#stimulus ID
tmin = -0.2 #start time 200ms before the event
tmax = 0.5 #end time 500ms after the event

# # #baseline
baseline = (None, 0) #means from the first instant to t = 0 
# # #defining EPOCHS
picks = mne.pick_channels(ch_names=raw.ch_names, include=['RAW_TP9'])
# , 'RAW_AF7', 'RAW_AF8', 'RAW_TP10'

epochs = mne.Epochs(raw, events, event_id, tmin, tmax, proj=True, picks=['eeg'], baseline=baseline, preload=True)
# # #artifact rejection
# # eog_projs, _ = mne.preprocessing.compute_proj_eog(raw, n_eeg=1, ch_name='EOG 61')
# # raw.add_proj(eog_projs)

# # #evoked events
evoked_left = epochs['Left'].average()
evoked_right = epochs['Right'].average()

# # # compare conditions--this needs to be augmented
mne.viz.plot_compare_evokeds(dict(left=evoked_left, right=evoked_right), legend='upper left', show_sensors='upper right')
